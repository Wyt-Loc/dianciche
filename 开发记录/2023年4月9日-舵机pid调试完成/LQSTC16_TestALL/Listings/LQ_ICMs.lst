C251 COMPILER V5.57.0,  LQ_ICMs                                                            03/01/21  13:27:05  PAGE 1   


C251 COMPILER V5.57.0, COMPILATION OF MODULE LQ_ICMs
OBJECT MODULE PLACED IN .\Objects\LQ_ICMs.obj
COMPILER INVOKED BY: D:\Keil_v5\C251\BIN\C251.EXE LQlib\app\LQ_ICMs.c LARGE INTR2 BROWSE INCDIR(.\user;.\LQlib\app;.\LQl
                    -ib\ddc;.\LQlib\driver) DEBUG PRINT(.\Listings\LQ_ICMs.lst) TABS(2) OBJECT(.\Objects\LQ_ICMs.obj) 

stmt  level    source

    1          /*LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
    2          【平    台】北京龙邱智能科技自平衡摩托车
    3          【编    写】chiusir
    4          【E-mail  】chiusir@163.com
    5          【软件版本】V1.1 版权所有，单位使用请先联系授权
    6          【最后更新】2020年4月10日
    7          【相关信息参考下列地址】
    8          【网    站】http://www.lqist.cn
    9          【淘宝店铺】http://longqiu.taobao.com
   10          ------------------------------------------------
   11          【dev.env.】Keil5.2及以上版本
   12          【Target 】 STC16F40K
   13          【SYS PLL】 36MHz
   14          =================================================================
   15          程序配套视频地址：https://space.bilibili.com/95313236
   16          下载时, 选择时钟 30MHZ (用户可自行修改频率).
   17          QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ*/
   18          #include "include.h"
   19          
   20          #define USE_SOFT_SPI //使用模拟SPI,否则使用硬件SPI
   21          
   22          float temp_p=0;
   23          
   24          
   25          
   26          #ifdef USE_ICM20689
               
               /*LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
               【作  者】chiusir
               【功能说明】初始化 ICM20689
               【软件版本】V1.0
               【最后更新】2020年12月21日 
               【函数名】
               【返回值】无 0：初始化成功   1：失败
               【参数值】无 
               QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ*/
               u8 ICM20689_Init(void)
               {
                 char  txt[10];
                 u8 res;
                 
                 ICM_SPI_Init(); 
                 delayms(100);  
                 res=ICM_Read_Byte(WHO_AM_I);                        //读取ICM20689的ID  
                 sprintf(txt,"ID:0x%02X",res);
                 OLED_P6x8Str(1,1,txt); 
                 
                 if(res!=ICM20689_ID)                                 //器件ID正确
                 {    
                   //printf("ID=%#X\r\n",res);
                   //OLED_P6x8Str(1,4,"ID is fail!");
                   return 1;
                 }
                 else  
                 {
                   //printf("ICM20689 is OK!\n");  
                 }    
                 
C251 COMPILER V5.57.0,  LQ_ICMs                                                            03/01/21  13:27:05  PAGE 2   

                 ICM_Write_Byte(ICM_PWR_MGMT1_REG,0X80);//复位
                 delayms(100);  //延时100ms
                 ICM_Write_Byte(ICM_PWR_MGMT1_REG,0X00);//唤醒
                 delayms(100);  //延时100ms
                 
                 ICM_Set_Gyro_Fsr(3);       //陀螺仪传感器,±2000dps   
                 ICM_Set_Accel_Fsr(1);      //加速度传感器,0:±2g   1:±4g    2:±8g
                 ICM_Set_Rate(1000);        //设置采样率1000Hz
                 //ICM_Write_Byte(ICM_CFG_REG,0x02);    //设置数字低通滤波器   98hz
                 ICM_Write_Byte(ICM_CFG_REG,4);         //低通滤波频率，典型值：0x07(3600Hz)此寄存器内决定Internal_Sample
             -_Rate==8K
                 ICM_Write_Byte(ICM_INT_EN_REG,0X00);   //关闭所有中断
                 ICM_Write_Byte(ICM_FIFO_EN_REG,0X00);  //关闭FIFO
                 ICM_Write_Byte(ICM_USER_CTRL_REG,0X00);//I2C主模式关闭
                 ICM_Write_Byte(ICM_PWR_MGMT1_REG,0X01);//设置CLKSEL,PLL X轴为参考
                 ICM_Write_Byte(ICM_PWR_MGMT2_REG,0X00);//加速度与陀螺仪都工作 
                 
                 return 0;
               }
               /*LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
               【作  者】chiusir
               【功能说明】读取 ICM20689 的原始数据
               【软件版本】V1.0
               【最后更新】2020年12月21日 
               【函数名】
               【返回值】无 0：初始化成功   1：失败
               【参数值】无 
               QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ*/
               void Test_ICMmodule(void)
               {
                 char  txt[16];
                 short data aacx,aacy,aacz;          //加速度传感器原始数据
                 short data gyrox,gyroy,gyroz;        //陀螺仪原始数据 
                 
                 OLED_CLS();                   //LCD清屏
                 OLED_P6x8Str(1,0,"LQ20689M Test"); 
                 delayms(100);
                 if(ICM20689_Init())
                 {     
                   OLED_P6x8Str(1,1,"LQ20689M Fail");
                   while(1);
                 }
                 
                 while(1)
                 {
                   
                   //测试原始数值
                   ICM_Get_Raw_data(&aacx,&aacy,&aacz,&gyrox,&gyroy,&gyroz); //得到加速度传感器数据  
                   
                   sprintf((char*)txt,"angle:%f",atan2((float)aacz,(float)aacx)*180.0/PI); //反正切加速度计得到角度值
                   OLED_P6x8Str(0,1,(u8*)txt);
                   
                   /*
                   Kalman_Filter((float)aacz,(float)(0-gyroy)); //卡尔曼
                   sprintf((char*)txt,"g_angle:%f",Angle); 
                   OLED_P6x8Str(0,2,(u8*)txt);
                   sprintf((char*)txt,"Ang_Y:%f",angle_dot);//X轴加速度值                      
                   OLED_P6x8Str(0,3,(u8*)txt);
                   */
                   
                   sprintf((char*)txt,"ax:%06d",aacx);  //X轴加速度值                      
                   OLED_P6x8Str(0,2,(u8*)txt);
                   sprintf((char*)txt,"ay:%06d",aacy);  //Y轴加速度值
                   OLED_P6x8Str(0,3,(u8*)txt);
                   sprintf((char*)txt,"az:%06d",aacz);  //Z轴加速度值
                   OLED_P6x8Str(0,4,(u8*)txt);
C251 COMPILER V5.57.0,  LQ_ICMs                                                            03/01/21  13:27:05  PAGE 3   

                   sprintf((char*)txt,"gx:%06d",gyrox); //X轴角度值
                   OLED_P6x8Str(0,5,(u8*)txt);
                   sprintf((char*)txt,"gy:%06d",gyroy); //Y轴角度值
                   OLED_P6x8Str(0,6,(u8*)txt);
                   sprintf((char*)txt,"gz:%06d",gyroz); //Z轴角度值
                   OLED_P6x8Str(0,7,(u8*)txt);
                   
                   /*
                   //测试简单融合结果
                   g_angle = ICM20689_ACC_angle_X_Z();
                   ICM20689_GYRO_Y_Ang();
                   ICM20689_GYRO_ACCEL_Ang_Y();
                   sprintf((char*)txt,"g_angle:%f",g_angle); 
                   OLED_P6x8Str(0,2,(u8*)txt);
                   sprintf((char*)txt,"Ang_Y:%f",GYRO_Ang_Y);//X轴加速度值                     
                   OLED_P6x8Str(0,3,(u8*)txt);
                   */
                   
                   
                   /*
                   printf("\r\nAX: %d  ",aacx); 
                   printf("\r\nAY: %d  ",aacy);
                   printf("\r\nAZ: %d  ",aacz); 
                   printf("\r\nGX: %d  ",gyrox);
                   printf("\r\nGY: %d  ",gyroy); 
                   printf("\r\nGZ: %d  ",gyroz);
                   printf("*********************");
                   */
                   delayms(100);    
                 }  
               }
               #elif defined USE_ICM42605
  156          /*************************************************************************
  157          *  函数名称：uint8_t icm42605_init(void)
  158          *  功能说明：ICM42605初始化
  159          *  参数说明：无
  160          *  函数返回：0 成功；1失败
  161          *  修改时间：2020年8月10日
  162          *  备    注：   
  163          *************************************************************************/
  164          uint8_t icm42605_init(void)
  165          {   
  166   1        uint8_t reg_val;
  167   1        char  txt[30];
  168   1        
  169   1        ICM_SPI_Init();  
  170   1        delayms(200);  
  171   1        
  172   1        reg_val = ICM_Read_Byte(WHO_AM_I);//WHO_AM_I
  173   1        sprintf(txt,"ID:0x%02X",reg_val);
  174   1        OLED_P8x16Str(66,2,(uint8_t*)txt);
  175   1        
  176   1        icm42605_write_reg(reg_bank_sel,0x00);//Set to bank 0
  177   1        icm42605_write_reg(reg_bank_sel,0x00);//Set to bank 0
  178   1        icm42605_write_reg(device_config_reg,bit_soft_reset_chip_config);//chip soft reset
  179   1        delayms(100);  
  180   1        
  181   1        if(reg_val==0x42)
  182   1        {
  183   2          icm42605_write_reg(reg_bank_sel,0x01);//Change to bank 1
  184   2          icm42605_write_reg(intf_config4,0x02);//4 wire spi mode
  185   2          
  186   2          icm42605_write_reg(reg_bank_sel,0x00);        
  187   2          icm42605_write_reg(fifo_config_reg,0x40);//Stream-to-FIFO Mode
  188   2          
  189   2          reg_val = ICM_Read_Byte(int_source0_reg);      
C251 COMPILER V5.57.0,  LQ_ICMs                                                            03/01/21  13:27:05  PAGE 4   

  190   2          icm42605_write_reg(int_source0_reg,0x00);    
  191   2          icm42605_write_reg(fifo_config2_reg,0x00);// watermark
  192   2          icm42605_write_reg(fifo_config3_reg,0x02);// watermark
  193   2          icm42605_write_reg(int_source0_reg, reg_val); 
  194   2          icm42605_write_reg(fifo_config1_reg,0x63);// Enable the accel and gyro to the FIFO
  195   2          
  196   2          icm42605_write_reg(reg_bank_sel,0x00);
  197   2          icm42605_write_reg(int_config_reg,0x36);   
  198   2          
  199   2          icm42605_write_reg(reg_bank_sel, 0x00);
  200   2          reg_val = (ICM_Read_Byte(int_source0_reg)|bit_int_fifo_ths_int1_en);      
  201   2          icm42605_write_reg(int_source0_reg, reg_val);
  202   2          
  203   2          icm42605_write_reg(reg_bank_sel, 0x00);
  204   2          reg_val = ((ICM_Read_Byte(accel_config0_reg)&0x1F)|(bit_accel_ui_fs_sel_8g));//8g
  205   2          icm42605_write_reg(accel_config0_reg, reg_val);
  206   2          
  207   2          icm42605_write_reg(reg_bank_sel, 0x00);
  208   2          reg_val = ((ICM_Read_Byte(accel_config0_reg)&0xF0)|bit_accel_odr_50hz);
  209   2          icm42605_write_reg(accel_config0_reg, reg_val); 
  210   2          
  211   2          icm42605_write_reg(reg_bank_sel, 0x00);
  212   2          reg_val = ((ICM_Read_Byte(gyro_config0_reg)&0x1F)|(bit_gyro_ui_fs_sel_1000dps));
  213   2          icm42605_write_reg(gyro_config0_reg,reg_val);
  214   2          
  215   2          icm42605_write_reg(reg_bank_sel, 0x00);      
  216   2          reg_val = ((ICM_Read_Byte(gyro_config0_reg)&0xF0)|bit_gyro_odr_50hz);
  217   2          icm42605_write_reg(gyro_config0_reg, reg_val); 
  218   2          
  219   2          icm42605_write_reg(reg_bank_sel, 0x00);
  220   2          reg_val = ICM_Read_Byte(pwr_mgmt0_reg)|(bit_accel_mode_ln); // Accel on in LNM
  221   2          icm42605_write_reg(pwr_mgmt0_reg, reg_val);  
  222   2          delayms(1);   
  223   2          
  224   2          icm42605_write_reg(reg_bank_sel, 0x00);
  225   2          reg_val = ICM_Read_Byte(pwr_mgmt0_reg)|(bit_gyro_mode_ln); // Gyro on in LNM
  226   2          icm42605_write_reg(pwr_mgmt0_reg, reg_val);  
  227   2          delayms(1);   
  228   2          printf("ok");
  229   2          OLED_P6x8Str(66,4,(uint8_t*)"Init Pass");
  230   2          return 0;
  231   2        }
  232   1        else 
  233   1        {
  234   2          OLED_P6x8Str(66,4,(uint8_t*)"Init Fail");
  235   2          return 1;
  236   2        }   
  237   1      }
  238          /*************************************************************************
  239          *  函数名称：void Test_ICM42605FIFO(void)
  240          *  功能说明：测试，读取加速度陀螺仪数据
  241          *  参数说明：无
  242          *  函数返回：无
  243          *  修改时间：2020年8月10日
  244          *  备    注：   
  245          *************************************************************************/
  246          void Test_ICM42605FIFO(void)
  247          {
  248   1        unsigned char  txt[30];
  249   1        //Sample_data_type_t *lqdat;
  250   1        short aacx,aacy,aacz;         //加速度传感器原始数据
  251   1        short gyrox,gyroy,gyroz;        //陀螺仪原始数据
  252   1        
  253   1        OLED_Init();                  //LCD初始化
  254   1        OLED_CLS();                   //LCD清屏
  255   1        OLED_P8x16Str(15,0,"ICM42605 Test"); 
C251 COMPILER V5.57.0,  LQ_ICMs                                                            03/01/21  13:27:05  PAGE 5   

  256   1        printf("\r\nLQ ICM42605 Test");  
  257   1        
  258   1        icm42605_init();
  259   1        
  260   1        while(1)
  261   1        {
  262   2          ICM_Get_Raw_data(&aacx,&aacy,&aacz,&gyrox,&gyroy,&gyroz); //得到加速度传感器数据  
  263   2          sprintf((char*)txt,"ax:%06d",aacx);
  264   2          OLED_P6x8Str(0,2,txt);
  265   2          sprintf((char*)txt,"ay:%06d",aacy);
  266   2          OLED_P6x8Str(0,3,txt);
  267   2          sprintf((char*)txt,"az:%06d",aacz);
  268   2          OLED_P6x8Str(0,4,txt);
  269   2          sprintf((char*)txt,"gx:%06d",gyrox);
  270   2          OLED_P6x8Str(0,5,txt);
  271   2          sprintf((char*)txt,"gy:%06d",gyroy);
  272   2          OLED_P6x8Str(0,6,txt);
  273   2          sprintf((char*)txt,"gz:%06d",gyroz);
  274   2          OLED_P6x8Str(0,7,txt);
  275   2          /*
  276   2          printf("\r\nAX: %d  ",aacx); 
  277   2          printf("\r\nAY: %d  ",aacy);
  278   2          printf("\r\nAZ: %d  ",aacz); 
  279   2          printf("\r\nGX: %d  ",gyrox);
  280   2          printf("\r\nGY: %d  ",gyroy); 
  281   2          printf("\r\nGZ: %d  ",gyroz);
  282   2          delayms(100);
  283   2          printf("\r\n*********************\n");
  284   2          */
  285   2        }  
  286   1      }
  287          
  288          #elif defined USE_ICM20602
               /*!
               * @brief    测试20602 SPI接线方式
               *
               * @param    无
               *
               * @return   无
               *
               * @note     无
               *
               * @see      Test_ICM20602();
               *
               * @date     2019/4/22 星期一
               */
               void Test_ICMmodule(void)
               {
                 char  txt[30];
                 short aacx,aacy,aacz;          //加速度传感器原始数据
                 short gyrox,gyroy,gyroz;        //陀螺仪原始数据
                 OLED_Init();                      //LCD初始化
                 OLED_CLS();                       //LCD清屏
                 
                 OLED_P8x16Str(15,0,"LQ 20602 Test");
                 
                 if(ICM20602_Init())
                 {
                   
                   OLED_P8x16Str(15,2,"ICM20602 Test Fail");
                   
                   while (1);
                   
                 }
                 
                 while(1)
C251 COMPILER V5.57.0,  LQ_ICMs                                                            03/01/21  13:27:05  PAGE 6   

                 {
                   ICM_Get_Raw_data(&aacx,&aacy,&aacz,&gyrox,&gyroy,&gyroz); //得到加速度传感器数据
                   sprintf((char*)txt,"ax:%06d",aacx);
                   OLED_P6x8Str(0,2,txt);
                   sprintf((char*)txt,"ay:%06d",aacy);
                   OLED_P6x8Str(0,3,txt);
                   sprintf((char*)txt,"az:%06d",aacz);
                   OLED_P6x8Str(0,4,txt);
                   sprintf((char*)txt,"gx:%06d",gyrox);
                   OLED_P6x8Str(0,5,txt);
                   sprintf((char*)txt,"gy:%06d",gyroy);
                   OLED_P6x8Str(0,6,txt);
                   sprintf((char*)txt,"gz:%06d",gyroz);
                   OLED_P6x8Str(0,7,txt);
                   
                   delayms(500);
                 }
               }
               
               /*!
               * @brief    初始化ICM20602 或者 ICM20602
               *
               * @param    无
               *
               * @return   0：初始化成功   1：失败
               *
               * @note     使用SPI接线方式的初始化
               *
               * @see      ICM20602_Init();
               *
               * @date     2019/6/12 星期三
               */
               unsigned char ICM20602_Init(void)
               {
                 unsigned char res;
                 ICM_SPI_Init(); 
                 res = ICM_Read_Byte(WHO_AM_I);           //读取ICM20602的ID
                 if(res == 0x12)                          //器件ID正确
                 {
                   //        PRINTF("ICM20602 is OK!\n");
                 }
                 else
                 {
                   //        PRINTF("\r\nThe correct IMU was not detected\r\nPlease check the wiring ID=%X\r\n",res);
                   return 1;
                 }
                 
                 
                 ICM_Write_Byte(ICM_PWR_MGMT1_REG,0X80);//复位ICM20602
                 delayms(100);  //延时100ms
                 ICM_Write_Byte(ICM_PWR_MGMT1_REG,0X00);//唤醒ICM20602
                 ICM_Set_Gyro_Fsr(3);            //陀螺仪传感器,±2000dps
                 ICM_Set_Accel_Fsr(1);         //加速度传感器,±4g
                 ICM_Set_Rate(1000);           //设置采样率1000Hz
                 ICM_Write_Byte(ICM_CFG_REG,0x02);      //设置数字低通滤波器   98hz
                 ICM_Write_Byte(ICM_INT_EN_REG,0X00);   //关闭所有中断
                 ICM_Write_Byte(ICM_USER_CTRL_REG,0X00);//I2C主模式关闭
                 ICM_Write_Byte(ICM_PWR_MGMT1_REG,0X01);//设置CLKSEL,PLL X轴为参考
                 ICM_Write_Byte(ICM_PWR_MGMT2_REG,0X00);//加速度与陀螺仪都工作
                 
                 if(res == 0)  //上面寄存器都写入成功
                 {
                   //        PRINTF("MPU set is OK!\n");
                 }
                 else return 1;
                 
C251 COMPILER V5.57.0,  LQ_ICMs                                                            03/01/21  13:27:05  PAGE 7   

                 return 0;
               }
               
               #endif
  392          
  393          
  394          
  395          
  396          
  397          
  398          
  399          
  400          
  401          
  402          
  403          
  404          
  405          
  406          
  407          /*************************************************************************
  408          *  函数名称：void ICM_SPI_Init(void)
  409          *  功能说明：模拟SPI口初始化
  410          *  参数说明：无
  411          *  函数返回：无
  412          *  修改时间：2020年8月10日
  413          *  备    注：   
  414          *************************************************************************/
  415          void ICM_SPI_Init(void)
  416          {
  417   1      #ifdef USE_SPI
                 SPI_init();
               #elif defined USE_SOFT_SPI
  420   1        Soft_SPI_Init();
  421   1      #endif
  422   1      }
  423          
  424          /*************************************************************************
  425          *  函数名称：void ICM_Read_Len(u8 reg,u8 len,u8 *buf)
  426          *  功能说明：u8 reg起始寄存器,u8 *buf数据指针,u16 len长度
  427          *  参数说明：无
  428          *  函数返回：无
  429          *  修改时间：2020年8月10日
  430          *  备    注：   
  431          *************************************************************************/
  432          void ICM_Read_Len(u8 reg,u8 len,u8 *buf)
  433          {  
  434   1      #ifdef USE_SOFT_SPI
  435   1        buf[0] = reg | 0x80;  
  436   1        Soft_SPI_ReadWriteNbyte(buf, len + 1);  
  437   1      #else
                 SPI_Read_Nbytes(reg|0x80, buf, len);
               #endif
  440   1      }
  441          /*************************************************************************
  442          *  函数名称：void ICM_Get_Gyroscope(short *gx,short *gy,short *gz)
  443          *  功能说明：
  444          *  参数说明：无
  445          *  函数返回：无
  446          *  修改时间：2020年8月10日
  447          *  备    注：   
  448          *************************************************************************/
  449          void ICM_Get_Gyroscope(short *gx,short *gy,short *gz)
  450          {
  451   1        u8 buf[7]; 
  452   1        ICM_Read_Len(ICM_GYRO_XOUTH_REG,6,buf);
  453   1        
C251 COMPILER V5.57.0,  LQ_ICMs                                                            03/01/21  13:27:05  PAGE 8   

  454   1        *gx=((u16)buf[1]<<8)|buf[2];  
  455   1        *gy=((u16)buf[3]<<8)|buf[4];  
  456   1        *gz=((u16)buf[5]<<8)|buf[6];
  457   1        
  458   1      }
  459          /*************************************************************************
  460          *  函数名称：void ICM_Get_Accelerometer(short *ax,short *ay,short *az)
  461          *  功能说明：
  462          *  参数说明：无
  463          *  函数返回：无
  464          *  修改时间：2020年8月10日
  465          *  备    注：   
  466          *************************************************************************/
  467          void ICM_Get_Accelerometer(short *ax,short *ay,short *az)
  468          {
  469   1        u8 buf[7];  
  470   1        ICM_Read_Len(ICM_ACCEL_XOUTH_REG,6,buf);
  471   1        
  472   1        *ax=((u16)buf[1]<<8)|buf[2];  
  473   1        *ay=((u16)buf[3]<<8)|buf[4];  
  474   1        *az=((u16)buf[5]<<8)|buf[6];  
  475   1      }
  476          
  477          /*************************************************************************
  478          *  函数名称：void ICM_Get_Raw_data(short *ax,short *ay,short *az,short *gx,short *gy,short *gz)
  479          *  功能说明：读取加速度陀螺仪数据
  480          *  参数说明：六轴
  481          *  函数返回：无
  482          *  修改时间：2020年8月10日
  483          *  备    注：   
  484          *************************************************************************/
  485          void ICM_Get_Raw_data(short *ax,short *ay,short *az,short *gx,short *gy,short *gz)
  486          {
  487   1        u8 buf[16];  
  488   1        ICM_Read_Len(ICM_ACCEL_XOUTH_REG,14,buf);
  489   1        
  490   1        *ax=((u16)buf[1]<<8)|buf[2];  
  491   1        *ay=((u16)buf[3]<<8)|buf[4];  
  492   1        *az=((u16)buf[5]<<8)|buf[6];
  493   1        *gx=((u16)buf[9]<<8)|buf[10];  
  494   1        *gy=((u16)buf[11]<<8)|buf[12];  
  495   1        *gz=((u16)buf[13]<<8)|buf[14];
  496   1      }
  497          
  498          /*************************************************************************
  499          *  函数名称：void ICM_Write_Byte(u8 reg,u8 value)
  500          *  功能说明：向寄存器写数据
  501          *  参数说明：u8 reg寄存器,u8 value数据
  502          *  函数返回：无
  503          *  修改时间：2020年8月10日
  504          *  备    注：   
  505          *************************************************************************/
  506          void ICM_Write_Byte(u8 reg,u8 value)
  507          {
  508   1      #ifdef USE_SOFT_SPI
  509   1        uint8_t buff[2];  
  510   1        buff[0] = reg;                  //先发送寄存器
  511   1        buff[1] = value;                //再发送数据  
  512   1        Soft_SPI_ReadWriteNbyte(buff, 2);//发送buff里数据，并采集到 buff里  
  513   1        
  514   1      #else
                 SPI_CS=0;
                 SPI_WriteByte(reg|0x80);
                 SPI_WriteByte(value);
                 SPI_CS=1;
               #endif
C251 COMPILER V5.57.0,  LQ_ICMs                                                            03/01/21  13:27:05  PAGE 9   

  520   1      }
  521          
  522          /*************************************************************************
  523          *  函数名称：void ICM_Write_Byte(u8 reg,u8 value)
  524          *  功能说明：向寄存器写数据
  525          *  参数说明：u8 reg寄存器,
  526          *  函数返回：u8 value数据
  527          *  修改时间：2020年8月10日
  528          *  备    注：   
  529          *************************************************************************/
  530          u8 ICM_Read_Byte(u8 reg)
  531          {  
  532   1        u8 buff[2];
  533   1      #ifdef USE_SOFT_SPI
  534   1        buff[0] = reg | 0x80;    //先发送寄存器  
  535   1        Soft_SPI_ReadWriteNbyte(buff, 2);   
  536   1        return buff[1];
  537   1      #else
                 SPI_CS=0;
                 SPI_WriteByte(reg| 0x80);  
                 buff[0]=SPI_ReadByte();
                 SPI_CS=1;
                 return buff[0];
               #endif  
  544   1        
  545   1      }
  546          /*************************************************************************
  547          *  函数名称：void ICM_Set_Gyro_Fsr(u8 fsr)
  548          *  功能说明：设置陀螺仪传感器满量程范围
  549          *  参数说明：Fsr:0,±250dps;1,±500dps;2,±1000dps;3,±2000dps
  550          *  函数返回：
  551          *  修改时间：2020年8月10日
  552          *  备    注：   
  553          *************************************************************************/
  554          void ICM_Set_Gyro_Fsr(u8 fsr)
  555          {
  556   1        ICM_Write_Byte(ICM_GYRO_CFG_REG,fsr<<3);//设置陀螺仪满量程范围  
*** ERROR C67 IN LINE 556 OF LQlib\app\LQ_ICMs.c: 'ICM_GYRO_CFG_REG': undefined identifier
*** WARNING C96 IN LINE 556 OF LQlib\app\LQ_ICMs.c: 'ICM_Write_Byte': too few actual parameters
  557   1      }
  558          /*************************************************************************
  559          *  函数名称：void ICM_Set_Accel_Fsr(u8 fsr)
  560          *  功能说明：设置LQ20689陀螺仪传感器满量程范围
  561          *  参数说明：fsr:0,±2g;1,±4g;2,±8g;3,±16g
  562          *  函数返回：
  563          *  修改时间：2020年8月10日
  564          *  备    注：   
  565          *************************************************************************/
  566          void ICM_Set_Accel_Fsr(u8 fsr)
  567          {
  568   1        ICM_Write_Byte(ICM_ACCEL_CFG_REG,fsr<<3);//设置加速度传感器满量程范围  
*** ERROR C67 IN LINE 568 OF LQlib\app\LQ_ICMs.c: 'ICM_ACCEL_CFG_REG': undefined identifier
*** WARNING C96 IN LINE 568 OF LQlib\app\LQ_ICMs.c: 'ICM_Write_Byte': too few actual parameters
  569   1      }
  570          /*************************************************************************
  571          *  函数名称：void ICM_Set_LPF(u16 lpf)
  572          *  功能说明：设置LQ20689数字低通滤波器
  573          *  参数说明：lpf:数字低通滤波频率(Hz)
  574          *  函数返回：
  575          *  修改时间：2020年8月10日
  576          *  备    注：   
  577          *************************************************************************/
  578          void ICM_Set_LPF(u16 lpf)
  579          {
  580   1        u8 dat=0;
  581   1        if(lpf>=188)dat=1;
C251 COMPILER V5.57.0,  LQ_ICMs                                                            03/01/21  13:27:05  PAGE 10  

  582   1        else if(lpf>=98)dat=2;
  583   1        else if(lpf>=42)dat=3;
  584   1        else if(lpf>=20)dat=4;
  585   1        else if(lpf>=10)dat=5;
  586   1        else dat=6; 
  587   1        ICM_Write_Byte(ICM_CFG_REG,dat);//设置数字低通滤波器  
*** ERROR C67 IN LINE 587 OF LQlib\app\LQ_ICMs.c: 'ICM_CFG_REG': undefined identifier
*** WARNING C96 IN LINE 587 OF LQlib\app\LQ_ICMs.c: 'ICM_Write_Byte': too few actual parameters
  588   1      }
  589          /*************************************************************************
  590          *  函数名称：void ICM_Set_Rate(u16 rate)
  591          *  功能说明：设置LQ20689陀螺仪传感器满量程范围
  592          *  参数说明：rate:4~1000(Hz)
  593          *  函数返回：
  594          *  修改时间：2020年8月10日
  595          *  备    注：   
  596          *************************************************************************/
  597          void ICM_Set_Rate(u16 rate)
  598          {
  599   1        u8 dat;
  600   1        if(rate>1000)rate=1000;
  601   1        if(rate<4)rate=4;
  602   1        dat=1000/rate-1;
  603   1        ICM_Write_Byte(ICM_SAMPLE_RATE_REG,dat);  //设置数字低通滤波器
*** ERROR C67 IN LINE 603 OF LQlib\app\LQ_ICMs.c: 'ICM_SAMPLE_RATE_REG': undefined identifier
*** WARNING C96 IN LINE 603 OF LQlib\app\LQ_ICMs.c: 'ICM_Write_Byte': too few actual parameters
  604   1        ICM_Set_LPF(rate/2);  //自动设置LPF为采样率的一半
  605   1      }
  606          /*************************************************************************
  607          *  函数名称：u16 ICM_Get_Temperature(void)
  608          *  功能说明：得到温度值
  609          *  参数说明：
  610          *  函数返回：返回值:温度值(扩大了100倍)
  611          *  修改时间：2020年8月10日
  612          *  备    注：返回值:温度值(扩大了100倍)   
  613          *************************************************************************/
  614          u16 ICM_Get_Temperature(void)
  615          {
  616   1        u8 buf[3]; 
  617   1        u16 raw;
  618   1        float temp;
  619   1        ICM_Read_Len(ICM_TEMP_OUTH_REG,2,buf); 
  620   1        raw=((u16)buf[0]<<8)|buf[1];  
  621   1        temp=21+((double)raw)/333.87;  
  622   1        return (u16)temp*100;
  623   1      }
  624          
  625          
  626          //*******************************************************************************************************
             -***************************************************
  627          void icm20689_reset()
  628          {
  629   1        ICM_Write_Byte(ICM_PWR_MGMT1_REG,0X80);   //复位
*** ERROR C67 IN LINE 629 OF LQlib\app\LQ_ICMs.c: 'ICM_PWR_MGMT1_REG': undefined identifier
*** WARNING C96 IN LINE 629 OF LQlib\app\LQ_ICMs.c: 'ICM_Write_Byte': too few actual parameters
  630   1        delayms(100);
  631   1        ICM_Write_Byte(ICM_PWR_MGMT1_REG, 0x00);  //解除休眠状态
*** ERROR C67 IN LINE 631 OF LQlib\app\LQ_ICMs.c: 'ICM_PWR_MGMT1_REG': undefined identifier
*** WARNING C96 IN LINE 631 OF LQlib\app\LQ_ICMs.c: 'ICM_Write_Byte': too few actual parameters
  632   1      }
  633          
  634          
  635          
  636          /*************************************************************************
  637          *  函数名称：uint8_t icm42605_write_reg(uint8_t reg,uint8_t value)
  638          *  功能说明：向寄存器写数据
C251 COMPILER V5.57.0,  LQ_ICMs                                                            03/01/21  13:27:05  PAGE 11  

  639          *  参数说明：uint8_t reg寄存器,uint8_t value数据
  640          *  函数返回：无
  641          *  修改时间：2020年8月10日
  642          *  备    注：   
  643          *************************************************************************/
  644          uint8_t icm42605_write_reg(uint8_t reg,uint8_t value)
  645          {
  646   1        uint8_t lqbuff[2];
  647   1        
  648   1        lqbuff[0] = reg;          //先发送寄存器
  649   1        lqbuff[1] = value;        //再发送数据
  650   1        
  651   1        Soft_SPI_ReadWriteNbyte(lqbuff, 2);//发送buff里数据，并采集到 buff里
  652   1        return 0;
  653   1      }
  654          /*************************************************************************
  655          *  函数名称：uint8_t icm42605_read_regs(uint8_t reg,uint8_t *buf,uint16_t len)
  656          *  功能说明：连续读取数据
  657          *  参数说明：uint8_t reg起始寄存器,uint8_t *buf数据指针,uint16_t len长度
  658          *  函数返回：无
  659          *  修改时间：2020年8月10日
  660          *  备    注：   
  661          *************************************************************************/
  662          uint8_t icm42605_read_regs(uint8_t reg,uint8_t *buf,uint16_t len)
  663          {   
  664   1        buf[0] = reg | 0x80;
  665   1        /* 写入要读的寄存器地址 */
  666   1        Soft_SPI_ReadWriteNbyte(buf, len + 1);
  667   1        return 0;
  668   1      }
  669          
  670          /*************************************************************************
  671          *  函数名称：void icm42605_read_fifo(Sample_data_type_t *lqdat,uint16_t len)
  672          *  功能说明：读取FIFO
  673          *  参数说明：无
  674          *  函数返回：无
  675          *  修改时间：2020年8月10日
  676          *  备    注：   
  677          *************************************************************************/
  678          uint8_t  fifocount_l, fifocount_h;
  679          uint16_t fifocount;
  680          
  681          void icm42605_read_fifo(Sample_data_type_t *lqdat,uint16_t len)
  682          {
  683   1        uint8_t reg_val;
  684   1        uint8_t tempbuff[512]={0};
  685   1        uint8_t i;
  686   1        
  687   1        reg_val = ICM_Read_Byte(int_source0_reg);      
  688   1        icm42605_write_reg(int_source0_reg,0x00); 
  689   1        
  690   1        fifocount_h = ICM_Read_Byte(fifo_byte_count_h_res); // Read the FIFO size
  691   1        fifocount_l = ICM_Read_Byte(fifo_byte_count_l_res);
  692   1        fifocount = (fifocount_h<<8)|fifocount_l;
  693   1        
  694   1        icm42605_read_regs(fifo_data_port,tempbuff,len);
  695   1        if(fifocount>=fifo_packet_size) // If we have a complete packet in the FIFO
  696   1        {
  697   2          for(i=0;i<32;i++)
  698   2          {
  699   3            if((tempbuff[i*16]&fifo_accel_en)&&(tempbuff[i*16]&fifo_gyro_en))
  700   3            {
  701   4              lqdat->Sample_accdata[0+i*3] = ((int16_t)((tempbuff[1+i*16] << 8) | tempbuff[2+i*16]))*acc_ssl;
  702   4              lqdat->Sample_accdata[1+i*3] = ((int16_t)((tempbuff[3+i*16] << 8) | tempbuff[4+i*16]))*acc_ssl;
  703   4              lqdat->Sample_accdata[2+i*3] = ((int16_t)((tempbuff[5+i*16] << 8) | tempbuff[6+i*16]))*acc_ssl;
  704   4              lqdat->Sample_gyrdata[0+i*3] = ((int16_t)((tempbuff[7+i*16] << 8) | tempbuff[8+i*16]))/gyr_ssl;
C251 COMPILER V5.57.0,  LQ_ICMs                                                            03/01/21  13:27:05  PAGE 12  

  705   4              lqdat->Sample_gyrdata[1+i*3] = ((int16_t)((tempbuff[9+i*16] << 8) | tempbuff[10+i*16]))/gyr_ssl;
  706   4              lqdat->Sample_gyrdata[2+i*3] = ((int16_t)((tempbuff[11+i*16]<< 8) | tempbuff[12+i*16]))/gyr_ssl;
  707   4            }
  708   3          }
  709   2        }
  710   1        icm42605_write_reg(int_source0_reg, reg_val); 
  711   1      }
  712          /*************************************************************************
  713          *  函数名称：void icm42605_stop(void)
  714          *  功能说明：停止工作
  715          *  参数说明：无
  716          *  函数返回：无
  717          *  修改时间：2020年8月10日
  718          *  备    注：   
  719          *************************************************************************/
  720          void icm42605_stop(void)
  721          {
  722   1        uint8_t reg_val; 
  723   1        icm42605_write_reg(reg_bank_sel, 0x00);
  724   1        reg_val = ICM_Read_Byte(pwr_mgmt0_reg)&(~bit_accel_mode_ln); // Accel off
  725   1        icm42605_write_reg(pwr_mgmt0_reg, reg_val);
  726   1        delayms(1);   
  727   1        
  728   1        icm42605_write_reg(reg_bank_sel, 0x00);
  729   1        reg_val = ICM_Read_Byte(pwr_mgmt0_reg)|(bit_gyro_mode_ln); // Gyro on in LNM
  730   1        icm42605_write_reg(pwr_mgmt0_reg, reg_val);   
  731   1        delayms(400);  
  732   1      }
  733          
  734          
  735          
  736          //
  737          
  738          

C251 COMPILATION COMPLETE.  6 WARNING(S),  6 ERROR(S)
