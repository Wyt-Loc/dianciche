C251 COMPILER V5.57.0,  LQ_I2C_9AX                                                         03/01/21  14:57:48  PAGE 1   


C251 COMPILER V5.57.0, COMPILATION OF MODULE LQ_I2C_9AX
OBJECT MODULE PLACED IN .\Objects\LQ_I2C_9AX.obj
COMPILER INVOKED BY: D:\Keil_v5\C251\BIN\C251.EXE LQlib\app\LQ_I2C_9AX.c LARGE INTR2 BROWSE INCDIR(.\user;.\LQlib\app;.\
                    -LQlib\ddc;.\LQlib\driver) DEBUG PRINT(.\Listings\LQ_I2C_9AX.lst) TABS(2) OBJECT(.\Objects\LQ_I2C_9AX.obj) 

stmt  level    source

    1          /*LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
    2          【平    台】北京龙邱智能科技TC264DA核心板
    3          【编    写】ZYF/chiusir
    4          【E-mail  】chiusir@163.com
    5          【软件版本】V1.1 版权所有，单位使用请先联系授权
    6          【最后更新】2020年4月10日
    7          【相关信息参考下列地址】
    8          【网    站】http://www.lqist.cn
    9          【淘宝店铺】http://longqiu.taobao.com
   10          ------------------------------------------------
   11          【dev.env.】Hightec4.9.3/Tasking6.3及以上版本
   12          【Target 】 TC264DA
   13          【Crystal】 20.000Mhz
   14          【SYS PLL】 200MHz
   15          ________________________________________________________________
   16          
   17          QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ*/
   18          
   19          #include <LQ_I2C_9AX.h>
   20          #include <LQ_OLED096.h>
   21          #include <LQ_I2C_soft.h>
   22          #include <LQ_SPI_soft.h>
   23          #include <stdio.h>
   24          
   25          /**
   26          * @brief    九轴测试
   27          *
   28          * @param
   29          *
   30          * @return
   31          *
   32          * @note
   33          *
   34          * @example
   35          *
   36          * @date     2019/6/13 星期四
   37          */
   38          void Test_9AX(void)
   39          {
   40   1        char  txt[30];
   41   1        short aacx,aacy,aacz;          //加速度传感器原始数据
   42   1        short gyrox,gyroy,gyroz;        //陀螺仪原始数据
   43   1        short magx, magy, magz;         //地磁计原始数据
   44   1        
   45   1        OLED_Init();                      //LCD初始化
   46   1        OLED_CLS();                       //LCD清屏
   47   1        
   48   1        IIC_Init();
   49   1        
   50   1        
   51   1        OLED_P8x16Str(15,0,"LQ 9AX Test");
   52   1        
   53   1        if(LQ9AX_Init())
   54   1        {
   55   2          
   56   2          OLED_P8x16Str(0,2,"9AX Test Fail");
   57   2      
   58   2          while (1);
C251 COMPILER V5.57.0,  LQ_I2C_9AX                                                         03/01/21  14:57:48  PAGE 2   

   59   2      
   60   2        }
   61   1        
   62   1        while(1)
   63   1        {
   64   2          FX_8700_GetACCRaw(&aacx,&aacy,&aacz);   //得到加速度传感器数据
   65   2          FX_8700_GetMAGRaw(&magx, &magy, &magz);
   66   2          FX_21002_GetRaw(&gyrox, &gyroy, &gyroz);
   67   2          
   68   2          sprintf((char*)txt,"ax:%06d",aacx);
   69   2          OLED_P6x8Str(0,2,txt);
   70   2          sprintf((char*)txt,"ay:%06d",aacy);
   71   2          OLED_P6x8Str(0,3,txt);
   72   2          sprintf((char*)txt,"az:%06d",aacz);
   73   2          OLED_P6x8Str(0,4,txt);
   74   2          sprintf((char*)txt,"gx:%06d",gyrox);
   75   2          OLED_P6x8Str(0,5,txt);
   76   2          sprintf((char*)txt,"gy:%06d",gyroy);
   77   2          OLED_P6x8Str(0,6,txt);
   78   2          sprintf((char*)txt,"gz:%06d",gyroz);
   79   2          OLED_P6x8Str(0,7,txt);
   80   2          sprintf((char*)txt,"MX:%5d ",magx);
   81   2          OLED_P6x8Str(60,5,txt);
   82   2          sprintf((char*)txt,"MY:%5d ",magy);
   83   2          OLED_P6x8Str(60,6,txt);
   84   2          sprintf((char*)txt,"MZ:%5d ",magz);
   85   2          OLED_P6x8Str(60,7,txt);
   86   2          
   87   2          delayms(100);    
   88   2        }  
   89   1      }
   90          
   91          
   92          
   93          /*!
   94          * @brief    九轴寄存器初始化
   95          *
   96          * @param    无
   97          *
   98          * @return   无
   99          *
  100          * @note     无
  101          *
  102          * @see      LQ9AX_Init();
  103          *
  104          * @date     2019/6/13 星期四
  105          */
  106          unsigned char LQ9AX_Init(void)
  107          {
  108   1        FX_8700_Active(0);
  109   1        delayms(10);
  110   1        
  111   1        if(FX_8700_Check())
  112   1        {
  113   2          //        PRINTF("\n FX_8700 Init Fail \n");
  114   2          return 1;
  115   2        }
  116   1        FX_8700_SetRate(800, 2);   // 800Hz  地磁和加速度计都使能
  117   1        FX_8700_SetRange(4);       //± 4g
  118   1        FX_8700_Active(1);
  119   1        
  120   1        
  121   1        FX_21002_Active(0);
  122   1        delayms(10);
  123   1        
  124   1        if(FX_21002_Check())
C251 COMPILER V5.57.0,  LQ_I2C_9AX                                                         03/01/21  14:57:48  PAGE 3   

  125   1        {
  126   2          //        PRINTF("\n FX_2100 Init Fail \n");
  127   2          return 2;
  128   2        }
  129   1        FX_21002_SetRate(800);     // 800Hz  角速度计
  130   1        FX_21002_SetRange(2000);   //± 2000dps
  131   1        FX_21002_SetLP(2);         //低通滤波
  132   1        FX_21002_Active(1);
  133   1        delayms(10);
  134   1        return 0;
  135   1      }
  136          
  137          
  138          
  139          
  140          
  141          
  142          
  143          
  144          
  145          
  146          /*!
  147          * @brief    设置FXOS8700 是否激活
  148          *
  149          * @param    enable :  1：激活  0：待机
  150          *
  151          * @return   0 : 成功  其他 ： 失败
  152          *
  153          * @note     无
  154          *
  155          * @see      FX_8700_Active(1); //使能
  156          *
  157          * @date     2019/6/13 星期四
  158          */
  159          unsigned char FX_8700_Active(unsigned char enable)
  160          {
  161   1        unsigned char reg;
  162   1        /* 开启高分辨率模式 */
  163   1        FX_Write_Byte(FXOS8700_ADDR, FXOS8701CQ_CTRL_REG2, 0x02);
  164   1        
  165   1        reg = FX_Read_Byte(FXOS8700_ADDR, FXOS8701CQ_CTRL_REG1);
  166   1        if(enable)
  167   1        {
  168   2          reg = reg | FXOS8701CQ_CTRL_REG1_ACTIVE;
  169   2        }
  170   1        else
  171   1        {
  172   2          reg = reg & ~FXOS8701CQ_CTRL_REG1_ACTIVE;
  173   2        }
  174   1        return FX_Write_Byte(FXOS8700_ADDR, FXOS8701CQ_CTRL_REG1, reg);
  175   1      }
  176          
  177          /*!
  178          * @brief    获取加速度计原始数据
  179          *
  180          * @param    ax,ay,az:加速度计x,y,z轴的原始读数(带符号)
  181          *
  182          * @return   0 : 成功  其他 ： 失败
  183          *
  184          * @note     无
  185          *
  186          * @see      int16_t data[3];
  187          * @see      FX_8700_GetACCRaw(&data[0], &data[1], &data[2]);//获取加速度原始数据
  188          *
  189          * @date     2019/6/13 星期四
  190          */
C251 COMPILER V5.57.0,  LQ_I2C_9AX                                                         03/01/21  14:57:48  PAGE 4   

  191          unsigned char FX_8700_GetACCRaw(short *ax,short *ay,short *az)
  192          {
  193   1        unsigned char buf[6],res;
  194   1        res = FX_Read_Len(FXOS8700_ADDR, FXOS8701CQ_OUT_X_MSB, 6, buf);
  195   1        if(res==0)
  196   1        {
  197   2          *ax = -((signed short)buf[0]<<8)|buf[1];
  198   2          *ay = -((signed short)buf[2]<<8)|buf[3];
  199   2          *az = ((signed short)buf[4]<<8)|buf[5];
  200   2        }
  201   1        return res;
  202   1      }
  203          
  204          
  205          /*!
  206          * @brief    获取地磁计计原始数据
  207          *
  208          * @param    mx,my,mz:地磁计x,y,z轴的原始读数(带符号)
  209          *
  210          * @return   0 : 成功  其他 ： 失败
  211          *
  212          * @note     无
  213          *
  214          * @see      int16_t data[3];
  215          * @see      FX_8700_GetMAGRaw(&data[0], &data[1], &data[2]);//获取地磁计原始数据
  216          *
  217          * @date     2019/6/13 星期四
  218          */
  219          unsigned char FX_8700_GetMAGRaw(short *mx,short *my,short *mz)
  220          {
  221   1        unsigned char buf[6],res;
  222   1        res = FX_Read_Len(FXOS8700_ADDR, FXOS8701CQ_M_OUT_X_MSB, 6, buf);
  223   1        if(res==0)
  224   1        {
  225   2          *mx = -((signed short)buf[0]<<8)|buf[1];
  226   2          *my = -((signed short)buf[2]<<8)|buf[3];
  227   2          *mz = ((signed short)buf[4]<<8)|buf[5];
  228   2        }
  229   1        return res;
  230   1      }
  231          
  232          
  233          
  234          /*!
  235          * @brief    设置FXOS8700 量程
  236          *
  237          * @param    dps :  设置量程 单位 度每秒
  238          *
  239          * @return   0 : 成功  其他 ： 失败
  240          *
  241          * @note     地磁计和加速度计 量程是一起设定的 ±2g;±0.244 mg/LSB   ±4g;±0.488 mg/LSB   ±8g ±0.976 mg
             -/LSB
  242          *
  243          * @see      FX_8700_SetRange(4); //设置量程 ±4g
  244          *
  245          * @date     2019/6/13 星期四
  246          */
  247          unsigned char FX_8700_SetRange(unsigned char mg)
  248          {
  249   1        unsigned char reg = FX_Read_Byte(FXOS8700_ADDR, FXOS8701CQ_XYZ_DATA_CFG);
  250   1        reg = reg & ~XYZ_DATA_CFG_FS_MASK;
  251   1        if(mg <= 2)
  252   1        {
  253   2          reg |= XYZ_DATA_CFG_FS_2G;
  254   2        }
  255   1        else if(mg <= 4)
C251 COMPILER V5.57.0,  LQ_I2C_9AX                                                         03/01/21  14:57:48  PAGE 5   

  256   1        {
  257   2          reg |= XYZ_DATA_CFG_FS_4G;
  258   2        }
  259   1        else
  260   1        {
  261   2          reg |= XYZ_DATA_CFG_FS_8G;
  262   2        }
  263   1        
  264   1        return FX_Write_Byte(FXOS8700_ADDR, FXOS8701CQ_XYZ_DATA_CFG, reg);
  265   1        
  266   1      }
  267          
  268          
  269          /*!
  270          * @brief    设置FXOS8700 采样速率
  271          *
  272          * @param    fps  设置输出速率 单位 1秒刷新多少次
  273          * @param    mode 0: 仅使用加速度计  1：仅使用地磁计  2：加速度计和地磁计都用（会导致输出速率减半）
  274          *
  275          * @return   0 : 成功  其他 ： 失败
  276          *
  277          * @note     无
  278          *
  279          * @see      FX_8700_SetRate(800, 2);   // 800Hz  地磁和加速度计都使能
  280          *
  281          * @date     2019/6/13 星期四
  282          */
  283          unsigned char FX_8700_SetRate(signed short fps, unsigned char mode)
  284          {
  285   1        unsigned char reg;
  286   1          
  287   1        if(mode == 0)
  288   1        {
  289   2          FX_Write_Byte(FXOS8700_ADDR, FXOS8701CQ_M_CTRL_REG1, 0x00);
  290   2        }
  291   1        else if(mode == 1)
  292   1        {
  293   2          FX_Write_Byte(FXOS8700_ADDR, FXOS8701CQ_M_CTRL_REG1, 0x01);
  294   2        }
  295   1        else
  296   1        {
  297   2          FX_Write_Byte(FXOS8700_ADDR, FXOS8701CQ_M_CTRL_REG1, 0x40|0x1C|0x03);
  298   2        }
  299   1        reg = FX_Read_Byte(FXOS8700_ADDR, FXOS8701CQ_CTRL_REG1);
  300   1        reg &= ~CTRL_REG_DR_MASK;
  301   1        
  302   1        if(fps <= 6)
  303   1        {
  304   2          reg |= CTRL_REG1_DR(6);
  305   2        }
  306   1        else if(fps <= 12)
  307   1        {
  308   2          reg |= CTRL_REG1_DR(5);
  309   2        }
  310   1        else if(fps <= 50)
  311   1        {
  312   2          reg |= CTRL_REG1_DR(4);
  313   2        }
  314   1        else if(fps <= 100)
  315   1        {
  316   2          reg |= CTRL_REG1_DR(3);
  317   2        }
  318   1        else if(fps <= 200)
  319   1        {
  320   2          reg |= CTRL_REG1_DR(2);
  321   2        }
C251 COMPILER V5.57.0,  LQ_I2C_9AX                                                         03/01/21  14:57:48  PAGE 6   

  322   1        else if(fps <= 400)
  323   1        {
  324   2          reg |= CTRL_REG1_DR(1);
  325   2        }
  326   1        else
  327   1        {
  328   2          reg |= CTRL_REG1_DR(0);
  329   2        }
  330   1        reg &= ~0x02;
  331   1        return FX_Write_Byte(FXOS8700_ADDR, FXOS8701CQ_CTRL_REG1, reg);
  332   1      }
  333          
  334          
  335          /*!
  336          * @brief    FXOS8700 自检
  337          *
  338          * @param    无
  339          *
  340          * @return   0 : 正常   其他：错误
  341          *
  342          * @note     无
  343          *
  344          * @see      FX_8700_Check(); //获取ID 检查是否连接正常
  345          *
  346          * @date     2019/6/13 星期四
  347          */
  348          unsigned char FX_8700_Check(void)
  349          {
  350   1        unsigned char ID = 0;
  351   1        
  352   1        ID = FX_Read_Byte(FXOS8700_ADDR, FXOS8701CQ_WHOAMI);
  353   1        if(FXOS8700CQ_WHOAMI_VAL == ID || FXOS8701CQ_WHOAMI_VAL == ID)
  354   1        {
  355   2          //        PRINTF("\n FXOS8700 is OK\n");
  356   2          return 0;
  357   2        }
  358   1        else
  359   1        {
  360   2          //        PRINTF("\n FXOS8700 is Failed\n\rCheck ID = %x \n" , ID);
  361   2        }
  362   1        return 1;
  363   1      }
  364          
  365          
  366          /*--------------------------------------------------------------------------------------
  367          ----------------------------------FXAS21002---------------------------------------------
  368          ----------------------------------------------------------------------------------------*/
  369          
  370          
  371          
  372          
  373          /*!
  374          * @brief    获取角速度计原始数据
  375          *
  376          * @param    gyrox,gyroy,gyroz:陀螺仪x,y,z轴的原始读数(带符号)
  377          *
  378          * @return   0 : 正常   其他：错误
  379          *
  380          * @note     无
  381          *
  382          * @see      int16_t data[3];
  383          * @see      FX_21002_GetRaw(&data[0], &data[1], &data[2]);//获取陀螺仪原始数据
  384          *
  385          * @date     2019/6/13 星期四
  386          */
  387          unsigned char FX_21002_GetRaw(short * gyrox, short *gyroy, short *gyroz)
C251 COMPILER V5.57.0,  LQ_I2C_9AX                                                         03/01/21  14:57:48  PAGE 7   

  388          {
  389   1        unsigned char buf[6],res;
  390   1        res = FX_Read_Len(FXAS21002C_ADDR, FXAS21002C_OUT_X_MSB, 6, buf);
  391   1        if(res==0)
  392   1        {
  393   2          *gyrox = ((signed short)buf[0]<<8)|buf[1];
  394   2          *gyroy = ((signed short)buf[2]<<8)|buf[3];
  395   2          *gyroz = ((signed short)buf[4]<<8)|buf[5];
  396   2        }
  397   1        return res;
  398   1      }
  399          
  400          
  401          /*!
  402          * @brief    设置FXAS21002 是否激活
  403          *
  404          * @param    enable :  1：激活  0：待机
  405          *
  406          * @return   0 : 正常   其他：错误
  407          *
  408          * @note     无
  409          *
  410          * @see      FX_21002_Active(1); //使能FX_21002
  411          *
  412          * @date     2019/6/13 星期四
  413          */
  414          unsigned char FX_21002_Active(unsigned char enable)
  415          {
  416   1        unsigned char reg = FX_Read_Byte(FXAS21002C_ADDR, FXAS21002C_CTRL_REG1);
  417   1        if(enable)
  418   1        {
  419   2          reg = reg | CTRL_REG1_ACTIVE;
  420   2        }
  421   1        else
  422   1        {
  423   2          reg = reg & ~CTRL_REG1_READY;
  424   2        }
  425   1        return FX_Write_Byte(FXAS21002C_ADDR, FXAS21002C_CTRL_REG1, reg);
  426   1      }
  427          
  428          
  429          
  430          /*!
  431          * @brief    设置FXAS21002 高通 滤波
  432          *
  433          * @param    BW :  设置截止频率（具体频率看表）
  434          *
  435          * @return   0 : 正常   其他：错误
  436          *
  437          * @note     不同采样频率下  高通滤波可以设置的值入下表
  438          *
  439          *    mode        采样速率    800 Hz 400 Hz 200 Hz  100 Hz 50 Hz  25 Hz 12.5 Hz
  440          *     0          截止频率      15    7.5    3.75   1.875  0.937 0.468  0.234
  441          *     1          截止频率     7.7   3.85   1.925   0.963  0.481 0.241  0.120
  442          *     2          截止频率     3.9   1.95   0.975   0.488  0.244 0.122  0.061
  443          *     3          截止频率    1.98   0.99   0.495   0.248  0.124 0.062  0.031
  444          *
  445          * @see      FX_21002_SetHP(0); //设置高通滤波
  446          *
  447          * @date     2019/6/13 星期四
  448          */
  449          unsigned char FX_21002_SetHP(unsigned char mode)
  450          {
  451   1        unsigned char reg = FX_Read_Byte(FXAS21002C_ADDR, FXAS21002C_CTRL_REG0);
  452   1        reg = reg | CTRL_REG0_HPF_EN;
  453   1        reg |= (mode << CTRL_REG0_SEL_SHIFTS);
C251 COMPILER V5.57.0,  LQ_I2C_9AX                                                         03/01/21  14:57:48  PAGE 8   

  454   1        return FX_Write_Byte(FXAS21002C_ADDR, FXAS21002C_CTRL_REG0, reg);
  455   1      }
  456          
  457          
  458          
  459          /*!
  460          * @brief    设置FXAS21002 低通 滤波
  461          *
  462          * @param    BW :  设置截止频率（具体频率看表）
  463          *
  464          * @return   0 : 正常   其他：错误
  465          *
  466          * @note     不同采样频率下  低通滤波可以设置的值入下表
  467          *  mode     采样速率  800 Hz  400 Hz  200 Hz  100 Hz  50 Hz  25 Hz  12.5 Hz
  468          *  0        截止频率  256     128      64      32     16      8        4
  469          *  1        截止频率  128      64      32      16      8      4       ―
  470          *  2        截止频率   64      32      16       8      4     ―       ―
  471          *
  472          * @see      FX_21002_SetLP(0) //如果采样速率 800Hz 则低通滤波截止频率 256
  473          *
  474          * @date     2019/6/13 星期四
  475          */
  476          unsigned char FX_21002_SetLP(unsigned char mode)
  477          {
  478   1        unsigned char reg = FX_Read_Byte(FXAS21002C_ADDR, FXAS21002C_CTRL_REG0);
  479   1        reg = reg & ~CTRL_REG0_BW_MASK;
  480   1        reg |= (mode << CTRL_REG0_BW_SHIFTS);
  481   1        return FX_Write_Byte(FXAS21002C_ADDR, FXAS21002C_CTRL_REG0, reg);
  482   1      }
  483          
  484          
  485          
  486          /*!
  487          * @brief    设置FXAS21002 量程
  488          *
  489          * @param    dps :  设置量程 单位 度每秒
  490          *
  491          * @return   0 : 正常   其他：错误
  492          *
  493          * @note     ±250dps;1,±500dps;2,±1000dps;3,±2000dps
  494          *
  495          * @see      FX_21002_SetRange(2000); //设置量程 ±2000dps
  496          *
  497          * @date     2019/6/13 星期四
  498          */
  499          unsigned char FX_21002_SetRange(unsigned short dps)
  500          {
  501   1        unsigned char reg = FX_Read_Byte(FXAS21002C_ADDR, FXAS21002C_CTRL_REG0);
  502   1        reg = reg & ~CTRL_REG0_FS_MASK;
  503   1        if(dps <= 250)
  504   1        {
  505   2          reg |= CTRL_REG0_FS_250_DPS;
  506   2        }
  507   1        else if(dps <= 500)
  508   1        {
  509   2          reg |= CTRL_REG0_FS_500_DPS;
  510   2        }
  511   1        else if(dps <= 1000)
  512   1        {
  513   2          reg |= CTRL_REG0_FS_1000_DPS;
  514   2        }
  515   1        else
  516   1        {
  517   2          reg |= CTRL_REG0_FS_2000_DPS;
  518   2        }
  519   1        
C251 COMPILER V5.57.0,  LQ_I2C_9AX                                                         03/01/21  14:57:48  PAGE 9   

  520   1        return FX_Write_Byte(FXAS21002C_ADDR, FXAS21002C_CTRL_REG0, reg);
  521   1        
  522   1      }
  523          
  524          
  525          /*!
  526          * @brief    设置FXAS21002 采样速率
  527          *
  528          * @param    fps 设置输出速率 单位 1秒刷新多少次
  529          *
  530          * @return   0 : 正常   其他：错误
  531          *
  532          * @note     无
  533          *
  534          * @see      FX_21002_SetRate(800); //设置采样率800Hz
  535          *
  536          * @date     2019/6/13 星期四
  537          */
  538          unsigned char FX_21002_SetRate(unsigned short fps)
  539          {
  540   1        unsigned char reg = FX_Read_Byte(FXAS21002C_ADDR, FXAS21002C_CTRL_REG1);
  541   1        reg &= ~CTRL_REG_DR_MASK;
  542   1        
  543   1        if(fps <= 13)
  544   1        {
  545   2          reg |= CTRL_REG_DR_12_5;
  546   2        }
  547   1        else if(fps <= 25)
  548   1        {
  549   2          reg |= CTRL_REG_DR_25HZ;
  550   2        }
  551   1        else if(fps <= 50)
  552   1        {
  553   2          reg |= CTRL_REG_DR_50HZ;
  554   2        }
  555   1        else if(fps <= 100)
  556   1        {
  557   2          reg |= CTRL_REG_DR_100HZ;
  558   2        }
  559   1        else if(fps <= 200)
  560   1        {
  561   2          reg |= CTRL_REG_DR_200HZ;
  562   2        }
  563   1        else if(fps <= 400)
  564   1        {
  565   2          reg |= CTRL_REG_DR_400HZ;
  566   2        }
  567   1        else
  568   1        {
  569   2          reg |= CTRL_REG_DR_800HZ;
  570   2        }
  571   1        return FX_Write_Byte(FXAS21002C_ADDR, FXAS21002C_CTRL_REG1, reg);
  572   1      }
  573          
  574          
  575          
  576          /*!
  577          * @brief    FXAS21002 自检
  578          *
  579          * @param    无
  580          *
  581          * @return   0 : 正常   其他：错误
  582          *
  583          * @note     无
  584          *
  585          * @see      FX_21002_Check(); //自检
C251 COMPILER V5.57.0,  LQ_I2C_9AX                                                         03/01/21  14:57:48  PAGE 10  

  586          *
  587          * @date     2019/6/13 星期四
  588          */
  589          unsigned char FX_21002_Check(void)
  590          {
  591   1        unsigned char ID = 0;
  592   1        
  593   1        ID = FX_Read_Byte(FXAS21002C_ADDR, FXAS21002C_WHO_AM_I);
  594   1        if(FXAS21002C_ID == ID)
  595   1        {
  596   2          //        PRINTF("\n FXAS21002 is OK\n");
  597   2          return 0;
  598   2        }
  599   1        else
  600   1        {
  601   2          //        PRINTF("\n FXAS21002 is Failed\n\rCheck ID = %x \n" , ID);
  602   2        }
  603   1        return 1;
  604   1      }
  605          
  606          
  607          
  608          
  609          
  610          
  611          
  612          
  613          /*--------------------------------------------------------------------------------------
  614          ----------------------------------底层驱动行数------------------------------------------
  615          ----------------------------------------------------------------------------------------*/
  616          
  617          
  618          
  619          
  620          
  621          /*!
  622          * @brief    IIC 连续读
  623          *
  624          * @param    addr:器件地址
  625          * @param    reg :要读取的寄存器地址
  626          * @param    len :要读取的长度
  627          * @param    buf :读取到的数据存储区
  628          *
  629          * @return   0 ：读取成功
  630          *
  631          * @note     移植时如果使用模拟IIC 需要修改这里
  632          *
  633          * @see      unsigned char buf[6],res;
  634          * @see      res = FX_Read_Len(FXAS21002C_ADDR, FXAS21002C_OUT_X_MSB, 6, buf);//读取陀螺仪数据
  635          *
  636          * @date     2019/6/12 星期三
  637          */
  638          unsigned char FX_Read_Len(unsigned char addr,unsigned char reg,unsigned char len,unsigned char *buf)
  639          {
  640   1        return IIC_ReadMultByteFromSlave(addr<<1, reg, len, buf);
  641   1      }
  642          
  643          
  644          
  645          /*!
  646          * @brief    IIC 写一个寄存器
  647          *
  648          * @param    addr  :器件地址
  649          * @param    reg   :要写的寄存器地址
  650          * @param    value :要写入的值
  651          *
C251 COMPILER V5.57.0,  LQ_I2C_9AX                                                         03/01/21  14:57:48  PAGE 11  

  652          * @return   0 ：读取成功
  653          *
  654          * @note     移植时如果使用模拟IIC 需要修改这里
  655          *
  656          * @see      FX_Write_Byte(FXAS21002C_ADDR, FXAS21002C_CTRL_REG1, 0x00); //写一个寄存器
  657          *
  658          * @date     2019/6/12 星期三
  659          */
  660          unsigned char FX_Write_Byte(unsigned char addr,unsigned char reg,unsigned char value)
  661          {
  662   1        return IIC_WriteByteToSlave(addr<<1, reg, value);
  663   1      }
  664          
  665          
  666          /*!
  667          * @brief    IIC 读一个寄存器
  668          *
  669          * @param    addr  :器件地址
  670          * @param    reg   :要读的寄存器地址
  671          *
  672          * @return   0 ：读取成功
  673          *
  674          * @note     移植时如果使用模拟IIC 需要修改这里
  675          *
  676          * @see      FX_Read_Byte(FXAS21002C_ADDR, FXAS21002C_WHO_AM_I); //读一个寄存器
  677          *
  678          * @date     2019/6/12 星期三
  679          */
  680          unsigned char FX_Read_Byte(unsigned char addr,unsigned char reg)
  681          {
  682   1        unsigned char value[1];
  683   1        FX_Read_Len(addr, reg, 1, value);
  684   1        return value[0];
  685   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1627     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------         91
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        98     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
